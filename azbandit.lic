=begin
This script will walk around looking for bandits until all group members have finished their bandit bounties.

It is untested outside of Kraken Falls, but should work anywhere.

It will work better if followers allow the leader to see their bounty via lichnet, e.g. ;lnet allow bounty all

# Name: azbandit
# Author: Azanoth
# Categories: Bounties
# Tags: bandit, bandits, bounty
# Version: 0.1
=end

# TODO large groups overwhelm lnet with requests - throttle lnet requests
status_tags 'on'
fput 'flag groupmovement on'
fput 'flag description on'

module AzBandit
  # user configurable (AKA STUFF YOU MIGHT ACTUALLY CARE ABOUT)
  @CAST_DISABLERS = true
  @CAST_DISABLERS_REPEATEDLY = true
  @DISABLER_MIN_MANA = 25
  @LOOTING_ENABLED = true # faster but you get less control over what gets looted

  # static variables
  @PROGRESS_UPDATE_INTERVAL = 1
  @DEBUG = false
  @BANDIT_BOUNTY = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?(.*?)\s(?:near|between|under|\.)/
  @BANDIT_SET =
    Set[
      'thief',
      'rogue',
      'bandit',
      'mugger',
      'outlaw',
      'highwayman',
      'marauder',
      'brigand',
      'thug',
      'robber'
    ]
  @BAD_LOCATIONS = /the town of Kharam-Dzu/
  @MY_CHARS_HACK = defined?($AZ_CHARS) ? $AZ_CHARS : []

  # dynamic variables
  @grouplist = []
  @groupset = {}
  @bounty_text = ''
  @bounty_location = ''
  @last_progress_update = nil
  @last_progress_msg = ''
  @step2_ways = {}
  @start_time = Time.now.to_f

  def self.main()
    if @LOOTING_ENABLED && !GameObj.inv.find { |x| x.noun == Vars.lootsack }
      raise "Failed to find lootsack (#{Vars.lootsack})"
    end

    # Setup
    @grouplist, @groupset = populate_group
    echo "Group is #{@grouplist.length ? @grouplist.join(', ') : 'empty'}"
    @bounty_text, @bounty_location = find_bounty_text
    exit_azbandit if all_done?
    echo "Bounty location is #{@bounty_location}"

    # Go to bounty area
    rooms_list = populate_rooms_list
    if !rooms_list.include? Room.current.id
      Script.run('go2', "#{rooms_list[0]}")
      sleep 0.5
      raise 'Failed to get to bounty area' if Room.current.id != rooms_list[0]
    end

    # Handle first room
    echo 'Handling first room' if @DEBUG
    wait_for_battle if game_obj_bandits.length > 0 && AzLib.room_owned?

    # Main loop - handle remaining rooms
    echo 'Handling remaining rooms' if @DEBUG
    prev_room = nil
    prev_room_poaching = nil
    step2_result = nil
    loop do
      poaching = !AzLib.room_owned?

      # Identify next room
      # (we prefer previous room unless we were poaching or are poaching in this
      #  room, to avoid getting stuck in e.g. y1/x2 in a x1-y1-x2 layout where
      #  another group is in y1)
      next_room =
        if Room.current.id != prev_room && prev_room && !prev_room_poaching &&
             !poaching
          prev_room
        else
          Room.current.find_nearest(rooms_list).to_i
        end

      if next_room == 0 || next_room.nil?
        rooms_list = populate_rooms_list
        next
      end

      # Step to next room (stores new step2_result)
      if Room.current.id != next_room
        prev_room = Room.current.id
        prev_room_poaching = !AzLib.room_owned?
        step2_result = step_to_next_room next_room
      end
      rooms_list = rooms_list.reject { |id| id == Room.current.id }
      next if !step2_result

      # Retrieve stragglers?
      has_stragglers =
        @grouplist.any? do |char|
          !AzLib.room_info.followers.any? { |f| f.noun == char }
        end
      step2_result = retrieve_stragglers prev_room if has_stragglers

      # Possibly wait for battle
      if step2_result['bandits'] && AzLib.room_owned?
        i = 0 # do the following at least once
        while i == 0 || (game_obj_bandits.length > 0 && AzLib.room_owned?)
          i = i + 1
          wait_for_battle
        end
      end
      exit_azbandit if all_done?
    end
  end

  def self.populate_rooms_list()
    $AZBANDIT_ROOM_CACHE = {} unless $AZBANDIT_ROOM_CACHE

    if !$AZBANDIT_ROOM_CACHE[@bounty_location]
      if @bounty_text =~ /Widowmaker's Road/
        $AZBANDIT_ROOM_CACHE[@bounty_location] = [
          29_021,
          29_022,
          29_023,
          29_024,
          29_025,
          29_026,
          29_027,
          29_028,
          29_029,
          29_030,
          29_050,
          29_051,
          29_053,
          29_054,
          29_055
        ]
      elsif @bounty_text =~ /Muddy Village/
        $AZBANDIT_ROOM_CACHE[@bounty_location] = [
          29_047,
          29_049,
          29_059,
          29_060,
          29_070,
          29_071,
          29_066,
          29_065
        ]
      elsif @bounty_text =~ /Cliffwalk/
        $AZBANDIT_ROOM_CACHE[@bounty_location] = [
          29_124,
          29_120,
          29_128,
          29_129,
          29_133,
          29_134,
          29_217,
          29_219,
          29_223,
          29_222
        ]
      elsif @bounty_text =~ /Black Weald/
        return [
          29_227,
          29_228,
          29_229,
          29_234,
          29_235,
          29_236,
          29_237,
          29_238,
          29_239,
          29_240,
          29_231,
          29_230
        ]
      else
        echo 'Loading bounty rooms...'
        $AZBANDIT_ROOM_CACHE[@bounty_location] =
          Room.list.find_all do |r|
            r.outside? && r.location =~ /#{@bounty_location}/i &&
              r.location !~ @BAD_LOCATIONS
          end.collect { |r| r.id }
        echo '...done!'
      end
    end
    return $AZBANDIT_ROOM_CACHE[@bounty_location]
  end

  def self.populate_group()
    status_tags 'off'
    grouplist = []
    groupset = {}
    fput 'group'
    while line = get
      if line =~
           /(\w+) is (?:following you|the leader of your group|also a member of your group)/i &&
           !$1.nil?
        grouplist.push($1)
        groupset[$1] = true
      elsif line =~
            /group status is currently|to set your group status|^.$|You are not currently in a group/m
        status_tags 'on'
        return grouplist, groupset
      end
    end
  end

  def self.find_bounty_text()
    bounty_text =
      [bounty?, *@grouplist.map { |n| LNet.get_data(n, 'bounty') }].find do |b|
        b =~ @BANDIT_BOUNTY
      end
    if !bounty_text
      raise 'Unable to find bandit bounty on you or group! Exiting'
    end
    return bounty_text, $1
  end

  def self.game_obj_bandits()
    return [] if GameObj.npcs.nil?
    return(
      GameObj.npcs.reject do |npc|
        npc.name.start_with?('animated ') ||
          !(npc.type =~ /bandit/ || @BANDIT_SET.include?(npc.noun))
      end
    )
  end

  def self.room_needs_looting?()
    echo 'room_needs_looting?' if @DEBUG
    return(
      GameObj.npcs.any? { |n| n.status == 'dead' } || GameObj.loot.any? do |n|
        #  n.type == "skin" ||
        n.type == 'gem' || n.name =~ /coins/
      end
    )
  end

  def self.step_to_next_room(room_id)
    # Step towards next room
    start_room_id = Room.current.id
    step2_result = nil

    while Room.current.id == start_room_id
      # prep for move
      fput 'stand' until standing?
      waitrt?
      GameObj.pcs.each do |pc|
        if @groupset[pc.noun] &&
             pc.status =~ /kneeling|sitting|lying down|prone/
          put "pull #{pc.noun}"
        end
      end

      # move
      step2_result = step_helper room_id
      echo "STEP2_RESULT: #{step2_result}" if @DEBUG

      # if we failed, check if we should now stay
      if Room.current.id == start_room_id
        sleep 0.25 # yield
        stay_here =
          AzLib.room_owned? &&
            (step2_result['bandits'] || game_obj_bandits.length > 0)

        if stay_here
          # couldn't move but that's okay cause we have bandits now
          echo "INFO: I don't need to move anymore - bandits are here and I'm not poaching"
          return { 'bandits' => true }
        end
      end
    end

    raise 'ERROR: no step2_result' if step2_result.nil?
    return step2_result
  end

  def self.step_helper(destination_room)
    # adapted from step2.lic
    if @DEBUG
      echo "running step2 towards #{destination_room} (current #{Room.current.id})"
    end
    unless Room.current.id
      raise 'current room was not found in the map database'
    end
    unless destination_room
      raise 'destination room was not found in the map database'
    end

    start_room = Room.current.id
    if start_room == destination_room
      raise 'ERROR: start room and destination room are the same'
    end

    key = "#{start_room}->#{destination_room}"
    unless @step2_ways[key]
      previous, shortest_distances =
        Map.dijkstra(Room.current.id, destination_room)
      unless previous[destination_room]
        echo "error: failed to find a path between your current room (#{start_room}) and destination room (#{destination_room})"
        exit
      end
      path = [destination_room]
      path.push(previous[path[-1]]) until previous[path[-1]].nil?
      path.reverse!
      @step2_ways[key] =
        Room.current.wayto[path[path.index(start_room) + 1].to_s]
    end

    # drain get? buffer
    sleep 0.01 # yield
    while line = get?
      next
    end

    # move
    way = @step2_ways[key]
    fput 'stand' until standing?
    if way.class == String
      put way
    elsif way.class == Proc
      raise 'Unhandled way.class == Proc'
      # way.call
    else
      raise 'error in the map database'
    end
    room_info = AzLib.wait_for_room_change

    # return new state
    poaching = !AzLib.room_owned?
    result = { 'bandits' => false }
    echo "Poaching: #{poaching}"

    if !room_info
      echo 'WARNING: step2 timed out'
      return result
    end

    loop do
      line = get?
      return result if !line
      if count = match_dialog_data_targets(line)
        # TODO move to AzLib
        result['bandits'] = count > 0
      end
    end
  end

  def self.retrieve_stragglers(prev_room_id)
    echo 'Retrieving stragglers'
    stragglers = identify_stragglers
    while stragglers.length > 0
      put 'look'
      sleep 0.5 # try again in a second - this thing is fiddly
      put 'look'
      sleep 0.5
      echo "whisper ooc group We left behind #{stragglers.join(' and ')}"
      step2_result = step2(prev_room_id)
      waitrt?
      stragglers.each { |char| fput "hold #{char}" }
      fput 'look'
      stragglers = identify_stragglers
      sleep 3 # if they're stunned, give other chars time to unstun them
      return step2_result if stragglers.length == 0 # we got em
    end
  end

  def self.identify_stragglers()
    pc_set = {}
    GameObj.pcs.each { |pc| pc_set[pc.noun] = true }
    return @grouplist.select { |name| !pc_set[name] }
  end

  def self.match_dialog_data_targets(line)
    # if line matches dialogData, return number of bandit targets in room
    # example: line matches, no bandits, returns 0
    # example: line matches, 3 bandits, returns 3
    # example: line doesn't match, returns nil
    # NOTE THAT THIS APPEARS TO BE A PARTIAL VIEW - NOT ALL BANDITS APPEAR HERE
    # UNCLEAR WHY IT IS PARTIAL OR WHAT RULES IT HAS
    bandit_count = nil
    if line =~
         %r{<dialogData id='combat'>.*content_text="(.*)" content_value="(.+?)" anchor_left.*<\/dialogData>}
      #<dialogData id='combat'><dropDownBox id='dDBTarget' value="none" cmd="target %dDBTarget%" tooltip='Select Target' content_text="none,human thief,halfling rogue" content_value="target help,#132801883,#132801878" anchor_left='cmdTarget' anchor_right='cmdAttack' height='20' width='80'  top='70' left='0' align='n'/></dialogData>
      echo({ 'text' => $1, 'value' => $2 }) if @DEBUG
      bandit_count = 0
      targets = $1.split(/\s*,\s*/)
      for i in 0..targets.length - 1
        t = targets[i].split(' ')[-1]
        next if t == 'none'
        bandit_count = bandit_count + 1 if @BANDIT_SET.include?(t)
      end
    end
    return bandit_count
  end

  def self.wait_for_battle()
    echo 'Bandits are here and we own the room'

    # bandits from <dialogData/> in feed
    # if nil, assume that there are some, we'll know soon enough
    dialog_data_bandits = nil # TODO pass in ids so we can do a diff?

    disabler_cast_count = 0
    disabler_cd_time = Time.now.to_i
    start_time = Time.now.to_i
    timeout_time = 2 # seconds
    lootsack = nil
    i = -1

    loop do
      if !AzLib.room_owned?
        echo "ERROR: How did we get here if we don't own the room?"
        return
      end
      sleep 0.25 # yield
      i = i + 1
      fput 'stand' until standing?

      # scan for dialog_data targets
      while line = get?
        match = match_dialog_data_targets(line)
        dialog_data_bandits = match if !match.nil?
      end

      # bandits from GameObj.targets
      local_game_obj_bandits = game_obj_bandits

      # timeout?
      if (
           dialog_data_bandits.nil? && game_obj_bandits.length == 0 &&
             Time.now.to_i > start_time + timeout_time
         )
        echo 'wait_for_battle timed out'
        return
      end

      # all done?
      any_bandits =
        if (
             # dialog_data_bandits doesn't seem reliable over time,
             # so we switch to game_obj_bandits after a bit
             dialog_data_bandits.nil? ||
               (Time.now.to_i < start_time + timeout_time)
           )
          true
        else
          local_game_obj_bandits.length > 0
        end
      return if !any_bandits

      # cast disabler?
      disablers_enabled =
        if disabler_cast_count == 0
          (@CAST_DISABLERS && @CAST_DISABLERS_REPEATEDLY)
        else
          @CAST_DISABLERS
        end
      can_cast =
        checkrt == 0 && checkcastrt == 0 && checkmana >= @DISABLER_MIN_MANA
      bandits_need_disabling =
        dialog_data_bandits.nil? ||
          dialog_data_bandits > 0 || local_game_obj_bandits.any? do |x|
          x.status.nil?
        end

      cast_disabler =
        disablers_enabled && can_cast && bandits_need_disabling &&
          Time.now.to_i >= disabler_cd_time
      if cast_disabler
        if Char.prof == 'Wizard' && Spell[410].known?
          waitrt?
          waitcastrt?
          multifput 'prep 410', 'cast'
        elsif Char.prof == 'Sorcerer' && Spell[709].known?
          Spell[709].cast
        end

        # cooldown: 0, 3, 8, 15.. (plus cast rt)
        disabler_cast_count = disabler_cast_count + 1
        disabler_cd_time =
          Time.now.to_i + disabler_cast_count.pow(2) + checkcastrt - 1
        next # restart wait_for_battle loop
      end

      # check if room needs to be looted
      if room_needs_looting?
        if !@LOOTING_ENABLED
          echo 'Waiting for looting' if i % 10 == 9
          next # restart wait_for_battle loop
        end
        waitrt?

        # search bodies
        bodies = local_game_obj_bandits.reject { |npc| npc.status != 'dead' }
        bodies.each_with_index { |bandit| fput "loot ##{bandit.id}" }

        # loot
        GameObj.loot.each do |x|
          if x.type == 'gem'
            if lootsack.nil?
              lootsack = GameObj.inv.find { |x| x.noun == Vars.lootsack }
              if !lootsack
                echo "WARNING: Failed to find lootsack (#{Vars.lootsack})"
                fput 'inv'
                sleep 1
                next # next item
              end
            end
            fput "_drag ##{x.id} ##{lootsack.id}"
          elsif x.name =~ /coins/
            fput 'get coins'
          end
        end

        next # restart wait_for_battle loop
      end

      # if we're here, it means bandits are still alive
      if i % 10 == 9
        echo 'Waiting for targets to be killed'
        echo "game_obj_bandits: #{local_game_obj_bandits.collect { |x| x.noun }}"
        echo "dialog_data_bandits: #{dialog_data_bandits}"
      end
    end
  end

  def self.exit_azbandit()
    if !@grouplist.all? { |char| checkpcs.include? char }
      raise 'Failed to find all group'
    end
    echo "Azbandit Running Time: #{Time.now.to_f - @start_time}"
    fput "whisper ooc group #{(Time.now.to_f - @start_time).to_i}"
    Script.start 'fbandit'
    exit
  end

  def self.all_done?()
    echo 'Checking if done' if @DEBUG
    counts = []
    shared_counts = $AZ_REMOTE['bandits'].get_counts

    [Char.name, *@grouplist].each do |name|
      raise "Unable to find bounty count - #{name}" if !shared_counts[name]
      next if $AZ_HAS_TAG.call $AZ_TAG_LOW_BOUNTY_PRIORITY, name
      counts.push shared_counts[name]
    end

    all_done = counts.all? { |count| count == 0 }
    give_progress_update =
      all_done || @last_progress_update.nil? ||
        @last_progress_update < Time.now.to_f - @PROGRESS_UPDATE_INTERVAL
    msg = shared_counts.map { |char, status| "#{char} #{status}" }.join('. ')

    if give_progress_update && msg != @last_progress_msg
      fput "whisper ooc group Status - #{msg} (#{(Time.now.to_f - @start_time).to_i})"
      @last_progress_update = Time.now.to_f
      @last_progress_msg = msg
    end

    return false if !all_done
    fput 'whisper ooc group Everyone is done!'
    return true
  end
end

AzBandit.main
