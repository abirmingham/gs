=begin
This script will walk around looking for bandits until all group members have finished their bandit bounties.

It is untested outside of Kraken Falls, but should work anywhere.

It will work better if followers allow the leader to see their bounty via lichnet, e.g. ;lnet allow bounty all

# Name: azbandit
# Author: Azanoth
# Categories: Bounties
# Tags: bandit, bandits, bounty
# Version: 0.1
=end

# TODO large groups overwhelm lnet with requests - throttle lnet requests
# TODO during combat if bandits hide the script will move on
# TODO script doesn't recognize arrow firing from shadows on group member

# before_dying {
#   status_tags "off"
# }
status_tags "on"
fput "flag groupmovement on"
fput "flag description on"

module AzBandit
  # static variables
  @PROGRESS_UPDATE_INTERVAL = 0.1
  @CAST_DISABLERS = true
  @CAST_DISABLERS_REPEATEDLY = true
  @DISABLER_MIN_MANA = 25
  @DEBUG = false
  @BANDIT_BOUNTY = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?(.*?)\s(?:near|between|under|\.)/
  @BANDIT_SET = Set["thief", "rogue", "bandit", "mugger", "outlaw", "highwayman", "marauder", "brigand", "thug", "robber"]
  @BAD_LOCATIONS = /the town of Kharam-Dzu/
  @NOT_ON_TASK = "not on task"
  @DIFFERENT_LOCATION_TASK = "different location bounty"
  @FINISHED = "finished"
  @DENIED = "denied"
  @MY_CHARS_HACK = ["Idios", "Azanoth", "Aranthius", 'Gossan', "Helsfeld"]

  # dynamic variables
  @grouplist = []
  @groupset = {}
  @bounty_text = ""
  @bounty_location = ""
  @deniers = {}
  @last_progress_update = nil
  @step2_ways = {}
  @start_time = Time.now.to_f

  def self.main()
    # Setup
    @grouplist, @groupset = populate_group()
    echo "Group is #{@grouplist.length ? @grouplist.join(", ") : "empty"}"
    @bounty_text, @bounty_location = find_bounty_text()
    exit_azbandit() if all_done?()
    echo "Bounty location is #{@bounty_location}"

    # Go to bounty area
    rooms_list = populate_rooms_list()
    if !rooms_list.include? Room.current.id
      move_to_bounty_area(rooms_list[0])
      sleep 0.5
      if Room.current.id != rooms_list[0]
        echo "Failed to get to bounty area"
        exit
      end
    end

    # Handle first room
    # TODO have this move to just outside the bounty area, then proceed as normal
    echo "Handling first room" if @DEBUG
    wait_for_battle() if game_obj_targets() > 0 && !is_poaching?()

    # Main loop - handle remaining rooms
    echo "Handling remaining rooms" if @DEBUG
    prev_room = nil
    prev_step2_result = nil
    step2_result = nil
    loop {
      prev_room_poaching = prev_step2_result && prev_step2_result['poaching']
      poaching = step2_result && step2_result['poaching']
      # Identify next room
      # (we prefer previous room unless we were poaching or are poaching in this
      #  room, to avoid getting stuck in e.g. y1/x2 in a x1-y1-x2 layout where
      #  another group is in y1)
      next_room = Room.current.id != prev_room && prev_room &&
                  !prev_room_poaching && !poaching ?
        prev_room :
        Room.current.find_nearest(rooms_list).to_i

      if next_room == 0 || next_room.nil?
        rooms_list = populate_rooms_list()
        next
      end

      # Step to next room
      if Room.current.id != next_room
        prev_room = Room.current.id
        prev_step2_result = step2_result
        step2_result = step_to_next_room(prev_step2_result || {}, next_room)
      end
      echo "rooms_list #{rooms_list}" if @DEBUG
      rooms_list = rooms_list.reject { |id| id == Room.current.id }
      next if !step2_result

      # Retrieve stragglers?
      if step2_result['stragglers']
        step2_result = retrieve_stragglers(prev_room)
      end

      # Possibly wait for battle
      if step2_result['bandits'] && !step2_result['poaching']
        wait_for_battle()
        exit_azbandit() if all_done?()
      end
    }
  end

  def self.move_to_bounty_area(first_room_id)
    # BEGIN handle jacked up KF map
    Script.run("go2", "28919") if is_kraken_falls_bounty() # move past jacked up map
    if @bounty_text =~ /Muddy Village/
      Script.run("go2", "29022")
      move "go village"
    elsif @bounty_text =~ /Black Weald/
      Script.run("go2", "29028")
      move "go trail"
    end
    # END
    Script.run("go2", "#{first_room_id}") unless Room.current.id == first_room_id
  end

  def self.is_kraken_falls_bounty()
    return !!(@bounty_text =~ /Widowmaker's Road/ or @bounty_text =~ /Muddy Village/ or @bounty_text =~ /Cliffwalk/ or @bounty_text =~ /Black Weald/)
  end

  def self.populate_rooms_list()
    $AZBANDIT_ROOM_CACHE = {} unless $AZBANDIT_ROOM_CACHE

    if !$AZBANDIT_ROOM_CACHE[@bounty_location]
      if @bounty_text =~ /Widowmaker's Road/
        $AZBANDIT_ROOM_CACHE[@bounty_location] = [29021, 29022, 29023, 29024, 29025, 29026, 29027, 29028, 29029, 29030, 29050, 29051, 29053, 29054, 29055]
      elsif @bounty_text =~ /Muddy Village/
        $AZBANDIT_ROOM_CACHE[@bounty_location] = [29047, 29049, 29059, 29060, 29070, 29071, 29066, 29065]
      elsif @bounty_text =~ /Cliffwalk/
        $AZBANDIT_ROOM_CACHE[@bounty_location] = [29124, 29120, 29128, 29129, 29133, 29134, 29217, 29219,29223, 29222]
      elsif @bounty_text =~ /Black Weald/
        return [29227, 29228, 29229, 29234, 29235, 29236, 29237, 29238, 29239, 29240, 29231, 29230]
      else
        echo "Loading bounty rooms..."
        $AZBANDIT_ROOM_CACHE[@bounty_location] = Room.list.find_all { |r|
          r.outside? &&
          r.location =~ /#{@bounty_location}/i &&
          r.location !~ @BAD_LOCATIONS
        }.collect { |r| r.id }
        echo "...done!"
      end
    end
    return $AZBANDIT_ROOM_CACHE[@bounty_location]
  end

  def self.populate_group()
    status_tags "off"
    grouplist = []
    groupset = {}
    fput "group"
    while line = get
      if line =~ /(\w+) is (?:following you|the leader of your group|also a member of your group)/i && !$1.nil?
        grouplist.push($1)
        groupset[$1] = true
      elsif line =~ /group status is currently|to set your group status|^.$|You are not currently in a group/m
        status_tags "on"
        return [grouplist, groupset]
      end
    end
  end

  def self.find_bounty_text()
    bounty_text = [
      bounty?,
      *@grouplist.map { |n| LNet.get_data(n, "bounty") },
    ].find { |b| b =~ @BANDIT_BOUNTY }
    if !bounty_text
      echo "Unable to find bandit bounty on you or group! Exiting"
      exit
    end
    return [bounty_text, $1]
  end

  def self.get_target_bounty_count(name)
    echo "get_target_bounty_count #{name}" if @DEBUG
    result = name == Char.name ? bounty? : LNet.get_data(name, "bounty")
    return @DENIED if result.nil?
    return @FINISHED if result =~ /^You succeeded in your task/
    if result =~ @BANDIT_BOUNTY
      return @DIFFERENT_LOCATION_TASK if !result.downcase.match(@bounty_location.downcase)
      bandit_count = result.scan(/\d+/).first
      if bandit_count.nil?
        echo "ERROR finding bandit count: #{result}"
        return 0
      end
      return bandit_count.to_i
    end
    return @NOT_ON_TASK
  end

  def self.game_obj_targets()
    return 0 if GameObj.npcs.nil?
    return GameObj.npcs.reject { |npc|
      npc.name.start_with?("animated ") ||
        !(npc.type =~ /bandit/ || @BANDIT_SET.include?(npc.noun))
    }.length
  end

  def self.room_needs_looting?()
    echo "room_needs_looting?" if @DEBUG
    return GameObj.npcs.any? { |n| n.status == "dead" } ||
             GameObj.loot.any? { |n|
              #  n.type == "skin" ||
               n.type == "gem" ||
               n.name =~ /coins/
             }
  end

  def self.is_poaching?()
    if @DEBUG
      echo "is_poaching? #{(checkpcs - @grouplist).count}"
      echo @grouplist
    end
    return (checkpcs - @grouplist).count > 0
  end

  def self.step_to_next_room(previous_result, room_id)
    # return if should_wait_for_actions?()

    # Step towards next room
    start_room_id = Room.current.id
    step2_result = nil
    while Room.current.id == start_room_id
      fput "stand" until standing?
      GameObj.pcs.each { |pc|
        if @groupset[pc.noun] and pc.status =~ /kneeling|sitting|lying down|prone/
          put "pull #{pc.noun}"
        end
      }
      step2_result = step2(previous_result, room_id)
      if !step2_result['moved']
        sleep 1
        if Room.current.id == start_room_id && game_obj_targets() > 0 && !is_poaching?()
          # not sure what happened but we seem to be in the clear
          return step2_result.merge({'bandits' => true})
        end
      end
    end

    throw "ERROR: no step2_result" if step2_result.nil?
    return step2_result
  end
  
  def self.step2(prev_result, destination_room)
    fput "stand" until standing?

    # adapted from step2.lic
    echo "running step2 towards #{destination_room} (current #{Room.current.id})" if @DEBUG
    throw "current room was not found in the map database" unless Room.current.id
    throw "destination room was not found in the map database" unless destination_room

    start_room = Room.current.id
    throw "ERROR: start room and destination room are the same" if start_room == destination_room

    key = "#{start_room}->#{destination_room}"
    unless @step2_ways[key]
      previous, shortest_distances = Map.dijkstra(Room.current.id, destination_room)
      unless previous[destination_room]
        echo "error: failed to find a path between your current room (#{start_room}) and destination room (#{destination_room})"
        exit
      end
      path = [destination_room]
      path.push(previous[path[-1]]) until previous[path[-1]].nil?
      path.reverse!
      @step2_ways[key] = Room.current.wayto[path[path.index(start_room) + 1].to_s]
    end

    # drain get? buffer
    while line = get?
      next
    end
    way = @step2_ways[key]

    # move
    start_time = Time.now().to_i
    if way.class == String
      move way, 2
    elsif way.class == Proc
      way.call
    else
      throw "error in the map database"
    end

    # return new state
    result = {
      "moved" => false,
      "bandits" => false,
      "poaching" => false,
      "stragglers" => false,
    }
    cleanup = Proc.new { |overrides|
      tmp = result.merge(overrides)
      echo tmp
      tmp
    }

    is_grouped = @grouplist.length > 0

    loop {
      line = get?
      # echo line
      if !line
        if Time.now().to_i >= start_time + 5 # seconds
          echo "WARNING: step2 timed out"
          return cleanup.call({'poaching' => true})
        end
        sleep 0.05
        next
      end

      if count = match_dialog_data_targets(line)
        result['bandits'] = count > 0
      elsif line =~ /^Also here:\s+(.*)/
        # Also here: Great Lady <a exist="-11144418" noun="Carolanne">Carolanne</a>, <a exist="-11178762" noun="Ithloria">Ithloria</a>
        # Check to see if we'd be poaching
        result['poaching'] = false
        # Parse xml with a regex? Seems like a bad idea, let's see how it turns out
        pcs = $1.split('noun="').reject { |x| x.start_with?('<a') }.collect { |x| x.split('"')[0] }
        echo "ALSO HERE PCS: #{pcs}"
        pcs.each do |pc|
          result['poaching'] = true if !@groupset[pc]
        end
        # note that in actuality we can generally assume that we're not poaching if we see Obvious paths/exits
        # before we see Also here:. However, there is ONE case where this isn't true - when we're picking up
        # a straggler. le sigh
      elsif !is_grouped && (line.start_with?('Obvious paths: ') || line.start_with?('Obvious exits: '))
        return cleanup.call({'moved' => true})
      elsif is_grouped && line.start_with?('<compass') && line =~ /<a exist=(.*) followed\.$/
        followers = $1.split('noun="').reject { |x| x.start_with?('<a') }.collect { |x| x.split('"')[0] }
        return cleanup.call({
          'moved' => true,
          'stragglers' => @grouplist.any? { |x| !followers.include? x },
        })
      elsif is_grouped && line.end_with?(' is unable to follow you.')
        return cleanup.call(prev_result.merge({'moved' => false}))
      end
    }
  end

  def self.retrieve_stragglers(prev_room_id)
    echo "Retrieving stragglers"
    stragglers = identify_stragglers()
    while stragglers.length > 0
      put "look"
      sleep 0.5 # try again in a second - this thing is fiddly
      put "look"
      sleep 0.5
      echo "whisper ooc group We left behind #{stragglers.join(" and ")}"
      step2_result = step2({}, prev_room_id)
      waitrt?
      stragglers.each { |char| fput "hold #{char}" }
      stragglers = identify_stragglers()
      return step2_result if stragglers.length == 0 # we got em
      sleep 3
    end
  end

  def self.identify_stragglers()
    pc_set = {}
    GameObj.pcs.each { |pc| pc_set[pc.noun] = true }
    return @grouplist.select { |name| !pc_set[name] }
  end

  def self.match_dialog_data_targets(line)
    # if line matches dialogData, return number of bandit targets in room
    # example: line matches, no bandits, returns 0
    # example: line matches, 3 bandits, returns 3
    # example: line doesn't match, returns nil
    bandit_count = nil
    if line =~ /<dialogData id='combat'>.*content_text="(.*)" content_value="(.+?)" anchor_left.*<\/dialogData>/
      #<dialogData id='combat'><dropDownBox id='dDBTarget' value="none" cmd="target %dDBTarget%" tooltip='Select Target' content_text="none,human thief,halfling rogue" content_value="target help,#132801883,#132801878" anchor_left='cmdTarget' anchor_right='cmdAttack' height='20' width='80'  top='70' left='0' align='n'/></dialogData>
      bandit_count = 0
      targets = $1.split(/\s*,\s*/)
      for i in 0..targets.length - 1
        t = targets[i].split(' ')[-1]
        next if t == 'none'
        bandit_count = bandit_count + 1 if @BANDIT_SET.include?(t)
      end
    end
    return bandit_count
  end

  def self.wait_for_battle()
    echo "Bandits are here and we own the room"    
    bandit_count = nil # TODO maybe pass in bandit count? we don't care though
    disabler_cast = false
    i = -1
    loop {
      fput "stand" until standing?
      i = i + 1
      while line = get?
        match = match_dialog_data_targets(line)
        bandit_count = match if !match.nil?
      end
      echo "waiting for battle" if @DEBUG

      # cast disabler
      disablers_enabled = disabler_cast ? (@CAST_DISABLERS && @CAST_DISABLERS_REPEATEDLY) : @CAST_DISABLERS
      can_cast = checkrt == 0 && checkcastrt == 0 && checkmana >= @DISABLER_MIN_MANA;
      any_unseen_bandits = bandit_count.nil? || bandit_count > game_obj_targets()
      if disablers_enabled && can_cast && any_unseen_bandits
        if Char.prof == "Wizard" && Spell[410].known?
          put "prep 410"
          fput "cast"
        elsif Char.prof == "Sorcerer" && Spell[709].known?
          put "prep 709"
          fput "cast"
        end
        disabler_cast = true
      end
      
      # check if room needs to be looted
      if room_needs_looting?()
        if @MY_CHARS_HACK.any? { |char| char == Char.name }
          waitrt?
          lootable = GameObj.npcs.reject { |npc| npc.status != 'dead' }
          lootable.each_with_index { |npc, i|
            # loot as fast as possible before running sloot
            # because sloot is kind of slow
            if i % 3 < 2 && i != lootable.length - 1
              put "search ##{npc.id}"
            else
              fput "search ##{npc.id}"
            end
          }
          sleep 0.25
          Script.run("sloot")
          next
        end

        echo "Waiting for loot to be picked up" if i % 10 == 9
        sleep 0.1
        next
      end

      return if bandit_count && bandit_count == 0 # all done
      # if we're here, it means bandits are still alive
      echo "Waiting for targets to be killed" if i % 10 == 9
      sleep 0.1
    }
  end

  def self.whisper_cmd(char, cmd, arg = "")
    fput "whisper ooc #{char} do:#{cmd}:#{arg}"
    while line = get
      # <pushStream id="speech"/><preset id="whisper">(OOC) Idios's player whispers,</preset> "DONE."
      return true if line =~ /\(OOC\) #{char}'s player whispers,.*"DONE/
      return false if line =~ /\(OOC\) #{char}'s player whispers,.*"FAIL/
    end
  end

  def self.exit_azbandit()
    pcs = GameObj.pcs.collect { |pc| pc.noun }
    if @MY_CHARS_HACK.any? { |char| char == Char.name } && @grouplist.all? { |char| pcs.include? char }
      # I'm in MY_CHARS_HACK and my entire group is here
      throw "Not done" unless bounty? =~ /^You succeeded in your task/
      @MY_CHARS_HACK.each { |char|
        if char != Char.name && char != 'Gossan' && char != 'Helsfeld' && pcs.include?(char)
          result = whisper_cmd(char, "verify-done")
          throw "Failed to verify" unless result
        end
      }
      Script.start("fbandit")
    end
    echo "Azbandit Running Time: #{Time.now.to_f - @start_time}"
    fput "whisper ooc group #{(Time.now.to_f - @start_time).to_i}"
    exit
  end

  def self.all_done?()
    echo "Checking if done" if @DEBUG
    status_by_char = {}
    counts = []
    [Char.name, *@grouplist].each { |name|
      status = get_target_bounty_count(name)

      if status == @DENIED
        echo "WARNING - #{name} denied your request for bounty information. Counting them as finished." if !@deniers[name]
        @deniers[name] = true
      end

      status_by_char[name] = status
      next if name == 'Gossan' || name == 'Helsfeld'
      counts.push(
        [@DENIED, @NOT_ON_TASK, @DIFFERENT_LOCATION_TASK, @FINISHED].include?(status) ?
          0 : status
      )
    }

    all_done = counts.all? { |count| count == 0 }
    give_progress_update = all_done ||
                           @last_progress_update.nil? ||
                           @last_progress_update < Time.now.to_f - @PROGRESS_UPDATE_INTERVAL

    if give_progress_update
      msg = status_by_char.map { |char, status| "#{char} #{status}" }.join(". ")
      fput "whisper ooc group Status - #{msg}"
      @last_progress_update = Time.now.to_f
    end

    if all_done
      fput "whisper ooc group Everyone is done!"
      if @deniers.length > 0
        echo "...except maybe those who aren't sharing bounty info via lich: #{@deniers.keys.join(", ")}"
      end
      return true
    end

    return false
  end
end

AzBandit.main()
