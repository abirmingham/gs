require 'drb/drb'
hide_me

DRb.start_service
$AZ_REMOTE = DRbObject.new_with_uri('druby://localhost:9999')

$AZ_CHARS = %w[Azanoth Aranthius Idios Gossan Gherraltis] # Helsfeld
$AZ_CHARS_REGEX = /#{$AZ_CHARS.join('|')}/
$AZ_CHARS_SET = $AZ_CHARS.collect { |char| [char, true] }.to_h

$AZ_TAG_SELLS_GEMS = 'sells_gems'
$AZ_TAG_GIVES_ARMOR_SUPPORT = 'gives_armor_support'
$AZ_TAG_RECEIVES_ARMOR_SUPPORT = 'receives_armor_support'
$AZ_TAG_WAGGLES_OTHERS = 'waggles_others'
$AZ_TAG_RESTING_GROUP_LEADER = 'resting_group_leader'
$AZ_TAG_LOW_BOUNTY_PRIORITY = 'low_bounty_priority'
$AZ_TAG_RUBS_WEAK_BROOCH = 'rubs_weak_brooch'
$AZ_TAG_CASTS_SHORT_BUFFS = 'casts_short_buffs'
$AZ_TAG_RECEIVES_515 = 'receives_515'
$AZ_TAG_RECEIVES_1601 = 'receives_1601'
$AZ_CHAR_TAGS =
  Hash[*$AZ_CHARS.collect { |x| [x, Set.new] }.flatten].merge(
    {
      'Azanoth' => Set.new([$AZ_TAG_GIVES_ARMOR_SUPPORT]),
      'Aranthius' =>
        Set.new(
          [
            $AZ_TAG_RUBS_WEAK_BROOCH,
            $AZ_TAG_RECEIVES_ARMOR_SUPPORT,
            $AZ_TAG_WAGGLES_OTHERS,
            $AZ_TAG_CASTS_SHORT_BUFFS,
            $AZ_TAG_SELLS_GEMS
          ]
        ),
      'Idios' => Set.new([$AZ_TAG_RUBS_WEAK_BROOCH, $AZ_TAG_RECEIVES_1601]),
      'Gossan' =>
        Set.new(
          [
            $AZ_TAG_LOW_BOUNTY_PRIORITY,
            $AZ_TAG_RUBS_WEAK_BROOCH,
            $AZ_TAG_RESTING_GROUP_LEADER,
            $AZ_TAG_CASTS_SHORT_BUFFS,
            $AZ_TAG_WAGGLES_OTHERS,
            $AZ_TAG_RECEIVES_515,
            $AZ_TAG_RECEIVES_1601
          ]
        ),
      'Gherraltis' =>
        Set.new(
          [
            $AZ_TAG_RECEIVES_515,
            $AZ_TAG_CASTS_SHORT_BUFFS
          ]
        )
    }
  )
$AZ_HAS_TAG =
  Proc.new { |tag, char = Char.name| $AZ_CHAR_TAGS[char].include? tag }

$AZ_PERSONAL_SCRIPTS =
  Hash[*$AZ_CHARS.collect { |x| [x, Proc.new {}] }.flatten].merge(
    {
      'Azanoth' =>
        Proc.new do
          # fput 'cman dervish'
          # waitrt?
          fput 'war shout'
          waitrt?
          if !Spell[9605].active? && !Spell[9606].active? && checkstamina >= 30
            fput 'cman surge'
          end
          Script.start 'Azanoth-506'
        end,
      'Gherraltis' => Proc.new { Spell[1608].cast }
    }
  )

# Poach Warning:
# Don't use fput for attacks, and check room id for fput on other things
$AZ_ATTACK_ROUTINE = {
  'Azanoth' =>
    Proc.new do |targets, room|
      if !Spell[506].active?
        echo 'NO 506!!!!!'
        sleep 1
      else
        fput 'stance off' until checkstance == 'offensive'
        put 'ambush' if room == Room.current.id
      end
    end,
  'Wizard' =>
    Proc.new do |targets, room|
      fput 'stance off' until checkstance == 'offensive'
      put 'incant 903' if checkmana >= 20 && room == Room.current.id
    end,
  'Bard' =>
    Proc.new do |targets, room|
      put 'incant 1030' if checkmana >= 60
      fput 'sym mana' if checkmana < 300 && !Spell[9048].active?
    end,
  'Paladin' =>
    Proc.new do |targets, room|
      if checkmana >= 40 && targets.any? { |x| !x.status || x.status == 'gone' }
        put 'incant 1630'
      else
        fput 'stance off' until checkstance == 'offensive'
        if room == current.id
          if checkstamina >= 30
            put 'shield strike'
          else
            put 'kill'
          end
      end
    end,
  'Empath' =>
    Proc.new do |targets, room|
      if checkmana >= 20
        put 'incant 1115'
      elsif checkmana >= 10
        put 'incant 1106'
      else
        echo 'WARNING: out of mana'
      end
    end
}

$AZ_BANDIT_TARGET_SET = {}
'rogue marauder thief mugger bandit brigand robber outlaw thug highwayman'
  .split(' ')
  .each { |noun| $AZ_BANDIT_TARGET_SET[noun] = true }
$AZ_BOUNTY_PATTERN_NUM = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?.*\s(?:near|between|under|\.).* (\d+) (?:more )?of them/
$AZ_BOUNTY_PATTERN_FINISHED = /^You (have )?succeeded/

$AZ_SEND_ACTION_SYNC =
  lambda do |char, cmd, arg = ''|
    echo "Queueing action - #{char} #{cmd} #{arg}"
    ACTIONS = $AZ_REMOTE['actions']
    id = ACTIONS.queue_action char, cmd, arg
    loop do
      sleep 0.25
      action = ACTIONS.get_action char, id
      throw 'Failed to get expected action' if !action
      if action['done']
        ACTIONS.clear_action char, id
        throw "ACTION HAS ERROR: #{action['error']}" if action['error']
        return
      end
    end
  end

module AzLib
  module RoomInfo
    @@HOOK_NAME = self.to_s
    @@room_info ||= OpenStruct.new(count: 0)
    @@room_info_mu = Mutex.new
    @@room_info_cv = ConditionVariable.new
    @@room_info_snap = @@room_info.clone
    @@move_timeout = 2 # seconds

    def self.room_info
      @@room_info_mu.synchronize { @@room_info_snap.clone }
    end

    def self.wait_for_room_change
      @@room_info_mu.synchronize do
        start = @@room_info_snap.count
        timeout_time = Time.now.to_i + @@move_timeout
        while start == @@room_info_snap.count
          now_time = Time.now.to_i
          if now_time >= timeout_time
            echo 'WARNING: wait_for_room_change timed out'
            break
          end
          @@room_info_cv.wait(@@room_info_mu, timeout_time - now_time)
        end
        start == @@room_info_snap.count ? nil : @@room_info_snap.clone
      end
    end

    def self.room_owned?(group = $AZ_CHARS_SET)
      @@room_info_mu.synchronize do
        ri = @@room_info_snap
        ri.other_pcs.find_all { |pc| !group.include?(pc.noun) }.empty? &&
          !ri.hiders
      end
    end

    DownstreamHook.add(
      @@HOOK_NAME,
      proc do |server_string|
        if server_string =~ /popStream.*id='room'/
          @@room_info.count += 1
          @@room_info.hiders = false
          @@room_info.other_pcs = []
        elsif @@room_info_snap.count != @@room_info.count
          if server_string =~ /obvious signs of someone hiding/
            @@room_info.hiders = true
          elsif server_string =~
                /^(?:Also here:|Also in the room:)(?<pc_str>.*)$/
            @@room_info.other_pcs = AzLib.get_gameobjs($~['pc_str'])
          elsif server_string =~ /(?<followers>.*) followed\./
            @@room_info.followers = AzLib.get_gameobjs($~['followers'])
          elsif server_string =~ /<prompt/
            @@room_info_mu.synchronize do
              @@room_info_snap = @@room_info.clone
              @@room_info_cv.broadcast
            end
          end
        end
        server_string
      end
    )
    echo "Added #{@@HOOK_NAME} hook"
    before_dying { DownstreamHook.remove @@HOOK_NAME }
  end

  module Targets
    @@HOOK_NAME = self.to_s
    @@targets ||= OpenStruct.new(dialog_data: [], game_obj: [])
    @@targets_mu = Mutex.new
    @@targets_cv = ConditionVariable.new
    @@targets_snap = @@targets.clone

    def self.targets
      @@targets_mu.synchronize do
        # return dialog_data and game_obj together deduped on id
        [*@@targets_snap.dialog_data, *@@targets_snap.game_obj].uniq do |x|
          x.id
        end
      end
    end

    def self.bandits
      targets.select do |npc|
        !npc.name.start_with?('animated ') &&
          (npc.type =~ /bandit/ || $AZ_BANDIT_TARGET_SET.include?(npc.noun))
      end
    end

    DownstreamHook.add(
      @@HOOK_NAME = self.to_s,
      proc do |server_string|
        if server_string =~
             %r{<dialogData id='combat'>.*content_text="(.*)" content_value="(.+?)" anchor_left.*<\/dialogData>}
          targets_raw = $1
          ids = $2.split /\s*,\s*/
          @@targets.dialog_data = []
          targets_raw
            .split(/\s*,\s*/)
            .each_with_index do |name, i|
              next if name == 'none'
              noun = name.split(/\s+/)[-1]
              @@targets.dialog_data.push GameObj.new(
                                           ids[i].sub('#', ''),
                                           noun,
                                           name
                                         )
            end
          @@targets_mu.synchronize do
            @@targets_snap = @@targets.clone
            @@targets_cv.broadcast
          end
        elsif server_string =~ /<prompt/
          # use npcs instead of targets so we see dead ones
          @@targets.game_obj = GameObj.npcs
          @@targets_mu.synchronize do
            @@targets_snap = @@targets.clone
            @@targets_cv.broadcast
          end
        end
        server_string
      end
    )
    echo "Added #{@@HOOK_NAME} hook"
    before_dying { DownstreamHook.remove @@HOOK_NAME = self.to_s }
  end

  # misc methods
  def self.get_gameobjs(line)
    line
      .scan(%r{<a exist="(-?\d+)" noun="([^"]+)">([^<]+)</a>})
      .map { |m| GameObj.new(m[0], m[1], m[2]) }
  end

  def self.should_defer?(a, b, current_counts, original_counts)
    # should 'a' defer to 'b'?
    return false if a == b
    a_is_tagged =
      current_counts[a] == 0 || current_counts[a] != original_counts[a]
    b_is_tagged =
      current_counts[b] == 0 || current_counts[b] != original_counts[b]
    if a_is_tagged
      if b_is_tagged
        false # may as well attack - neither need credit
      else
        # let them get credit as soon as I have less
        current_counts[a] <= current_counts[b]
      end
    else
      # let them get credit if they have more than me
      current_counts[a] < current_counts[b]
    end
  end
end

$AZ_BANDIT_ATTACK =
  Proc.new do |attack_routine|
    # wait for bounty
    echo 'Waiting for bounty'
    loop do
      if bounty? =~ $AZ_BOUNTY_PATTERN_NUM ||
           bounty? =~ $AZ_BOUNTY_PATTERN_FINISHED
        break
      end
      sleep 1
    end

    # send count to remote
    if bounty? =~ $AZ_BOUNTY_PATTERN_FINISHED
      # this should only happen if we killed char-bandits.lic and restarted it
      # mid-run, causing us to skip an update.
      $AZ_REMOTE['bandits'].set_count(Char.name, 0)
    elsif bounty? =~ $AZ_BOUNTY_PATTERN_NUM && $1.to_i
      $AZ_REMOTE['bandits'].set_count(Char.name, $1.to_i)
      echo "Set count #{$1}"
    else
      throw 'Failed to find bounty count'
    end

    echo 'Waiting for group registration'

    # wait for group registration
    loop do
      break if $AZ_REMOTE['bandits'].has_group_registered?
      sleep 1
    end

    # state
    last_bounty_text = ''
    original_bounty_counts = $AZ_REMOTE['bandits'].get_counts
    i_am_lower_priority = $AZ_HAS_TAG.call $AZ_TAG_LOW_BOUNTY_PRIORITY

    # main loop
    echo 'Main attack loop'
    i = -1
    while true
      i = i + 1
      fput 'stand' if !standing?

      # defer to others?
      bounty_counts = $AZ_REMOTE['bandits'].get_counts
      high_priority_counts =
        bounty_counts.reject do |char|
          $AZ_HAS_TAG.call($AZ_TAG_LOW_BOUNTY_PRIORITY, char)
        end

      defer = true
      if i_am_lower_priority
        # wait until I am last and all high-priority chars have tagged
        defer =
          high_priority_counts.any? do |char, their_count|
            their_count > bounty_counts[Char.name] ||
              their_count == original_bounty_counts[char]
          end
      else
        defer =
          high_priority_counts.any? do |char, their_count|
            AzLib.should_defer? Char.name,
                                char,
                                bounty_counts,
                                original_bounty_counts
          end
      end

      # identify targets
      targets =
        GameObj.npcs.select do |npc|
          $AZ_BANDIT_TARGET_SET[npc.noun] && npc.status != 'dead' &&
            !npc.name.start_with?('animated ')
        end

      # chill or attack
      room_owned = AzLib::RoomInfo.room_owned?
      echo "---- DEFER: #{defer}; room_owned: #{room_owned}" if i % 10 == 0

      if defer || !room_owned || targets.nil? || targets.length == 0
        if checkcastrt == 0
          fput 'stance def' if checkstance != 'defensive'
        elsif checkstance != 'guarded'
          fput 'stance def'
        end
      else
        # TODO adjust attack routines to attack specific targets
        attack_routine.call targets, Room.current.id
      end

      # yield
      rt = [checkrt, checkcastrt].max
      sleep(rt > 2 ? rt - 1 : 0.25)

      # update bounty count
      bounty_text = bounty?
      if last_bounty_text != bounty_text
        new_count = 100
        if bounty_text =~ $AZ_BOUNTY_PATTERN_FINISHED
          new_count = 0
        elsif bounty_text =~ $AZ_BOUNTY_PATTERN_NUM
          new_count = $1.to_i
        end
        $AZ_REMOTE['bandits'].set_count Char.name, new_count
        last_bounty_text = bounty_text
      end

      # yield
      sleep 0.25
    end
  end

$AZ_RUN_CMD =
  lambda do |cmd, arg|
    echo "run_cmd(#{cmd}, #{arg})"
    bounty_re = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?(.*)\s(?:near|between|under|\.)/
    if cmd == 'exchange-unless' && arg.length > 0
      if bounty? =~ bounty_re
        if $1 == arg
          echo 'ALREADY HAVE REQUESTED LOCATION'

          # also prep for bandits
          Script.start 'prep'
          return true
        end
      end
      wait_while { Spell[9056].active? }
      fput 'ask luc to remove'
      fput 'ask luc to remove'

      # also prep for bandits
      Script.start 'prep'
      return true
    elsif cmd == 'start-script' && arg.length > 0
      Script.start(arg) if !running? arg
      return true
    elsif cmd == 'stop-script' && arg.length > 0
      Script.kill(arg) if running? arg
      return true
    elsif cmd == 'wait_groupbounty_cooldown_unless' && arg.length > 0
      has_that_bounty = bounty? =~ bounty_re && $1 == arg
      if Spell[9056].active? && !has_that_bounty
        msg =
          "Group bounty in #{Spell[9056].timeleft.round(2)} minutes (ie #{(Spell[9056].timeleft * 60).round(0)} seconds)"
        fput "whisper ooc Aranthius #{msg}"
      end
      wait_while { Spell[9056].active? } unless has_that_bounty
      return true
    elsif cmd == 'ungroup'
      Script.running.each { |x| x.kill }
      fput 'disband'
      fput 'leave'
      fput 'group open'
      return true
    end
    echo 'SWITCH FALL THROUGH'
    return false
  end

loop do
  ACTIONS = $AZ_REMOTE['actions']
  actions = (ACTIONS.get_actions(Char.name) || []).reject { |x| x['done'] }
  actions.each do |action|
    success = $AZ_RUN_CMD.call(action['cmd'], action['args'])
    ACTIONS.mark_action_done(
      Char.name,
      action['id'],
      success ? nil : 'FAILED RUN_CMD'
    )
  end
  sleep 1
end
