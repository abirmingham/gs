require 'drb/drb'
hide_me

DRb.start_service
$AZANOTH_SHARED_OBJECT = DRbObject.new_with_uri('druby://localhost:9999')

$AZ_CHARS = ['Azanoth', 'Aranthius', 'Idios', 'Gossan', 'Helsfeld']
$AZ_CHARS_REGEX = /#{$AZ_CHARS.join('|')}/
$AZ_CHARS_SET = $AZ_CHARS.collect { |char| [char, true] }.to_h
$AZ_BANDIT_TARGET_SET = {}
"rogue marauder thief mugger bandit brigand robber outlaw thug highwayman".split(" ").each do |noun|
  $AZ_BANDIT_TARGET_SET[noun] = true
end
$AZ_BOUNTY_PATTERN_NUM = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?.*\s(?:near|between|under|\.).* (\d+) (?:more )?of them/
$AZ_BOUNTY_PATTERN_FINISHED = /^You succeeded in your task/

$AZ_BANDIT_ATTACK = Proc.new { |attack_routine|
  # state
  poaching = false
  carried_line = nil
  last_bounty_text = ''

  # main loop
  i = -1
  while true
    i = i + 1
    fput "stand" if !standing?

    # identify targets
    targets = GameObj.npcs.select do |npc|
      $AZ_BANDIT_TARGET_SET[npc.noun] && npc.status != "dead" && !npc.name.start_with?("animated ")
    end

    # check to see if we've moved, and whether we've progressed on bandits
    # we carry over the last line of the buffer to account for the situation
    # where we slurp a line that is important to our next loop iteration
    buffer = carried_line ? [carried_line] : []
    while line = get?
      buffer.push(line)
      carried_line = line
    end
    if carried_line && (carried_line.start_with?('Obvious paths:') || carried_line.start_with?('Obvious exits:'))
      # we don't want to consider this line in the next loop
      carried_line = nil
    end

    bounty_text = bounty?
    if last_bounty_text != bounty_text
      new_count = 100
      if bounty_text =~ $AZ_BOUNTY_PATTERN_FINISHED
        new_count = 0
      elsif bounty_text =~ $AZ_BOUNTY_PATTERN_NUM
        new_count = $1.to_i
      end
      $AZANOTH_SHARED_OBJECT['bandits'].set_count(Char.name, new_count)
      last_bounty_text = bounty_text
    end
    
    for i in 1..buffer.length do
      line = buffer[buffer.length - i]

      # NEXT STEPS:
      # examine poaching_solution.lic and figure out exactly what else we need to
      # read from the buffer to build a complete picture of the scene, probably
      # with status_tags.
      # Hopefully reuse this logic in a function in azbandit

      if line.start_with?('Obvious paths:') || line.start_with?('Obvious exits:')
        # previous line should be "Also here:" (unless we're leading)
        line = buffer[buffer.length - i - 1]
        if line && line.start_with?('Also here: ') && line =~ /^Also here: (.*)/
          # Check to see if we'd be poaching
          pcs = $1.split(', ').collect { |x|
            x.sub(/ who is .*/, '').split(' ')[-1] # remove status suffix and prename title
          }
          poaching = pcs.any? { |x| !$AZ_CHARS_SET[x] }
        elsif line && !group?
          # I must be leading and not poaching
          poaching = false
        else
          # Er... there should be SOME line, like a room description
          echo "WTF"
          echo "#{buffer.length} - #{i} - 1"
          echo buffer
          echo '-----------'
          # Following:
          # Lord Aranthius's group just went northeast.
          # [Muddy Village, Pathway - 29049]
          # The charred blah blah.
          # Also here: Gossan, Helsfeld, Idios, Lord Aranthius
          # Obvious paths: north, northeast, southwest
          # J>
          # Leading:
          # [azbandit]>northwest
          # [Black Weald, Sky Pond - 29228]
          # Far enough Blah blah
          # Obvious paths: southeast
          # Idios, Azanoth, Helsfeld and Gossan followed.
          # J>
          poaching = true
        end
        break
      end
    end

    if poaching || targets.nil? || targets.length == 0
      if checkcastrt == 0
        fput "stance def" if checkstance != "defensive"
      elsif checkstance != "guarded"
        fput "stance def"
      end
    elsif running? 'sloot'
      wait_while { running? 'sloot' }
    else
      attack_routine.call(targets)
    end

    rt = checkrt
    if rt > 2
      sleep(rt - 1)
    else
      sleep 0.25
    end
  end
}

def run_cmd(leader, cmd, arg)
  echo "run_cmd(#{cmd}, #{arg})"
  bounty_re = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?(.*)\s(?:near|between|under|\.)/
  if cmd == "exchange-unless" && arg.length > 0
    if bounty? =~ bounty_re
      if $1 == arg
        echo "ALREADY HAVE REQUESTED LOCATION"
        fput "whisper ooc #{leader} DONE"
        return
      end
    end
    wait_while { Spell[9056].active? }
    fput "ask luc to remove"
    fput "ask luc to remove"
    fput "whisper ooc #{leader} DONE"
    return
  elsif cmd == "ungroup"
    fput "disband"
    fput "leave"
    fput "group open"
    fput "whisper ooc #{leader} DONE"
    return
  elsif cmd == "start-script" && arg.length > 0
    fput "whisper ooc #{leader} DONE"
    Script.start(arg)
    return
  elsif cmd == "stop-script" && arg.length > 0
    fput "whisper ooc #{leader} DONE"
    Script.kill(arg) if running? arg
    return
  elsif cmd == "verify-done"
    result = bounty? =~ /^You succeeded in your task/ ? "DONE" : "FAIL"
    dothistimeout "whisper ooc #{leader} #{result}", 30, /You quietly whisper to /
    return
  elsif cmd == "wait_groupbounty_cooldown_unless" && arg.length > 0
    has_bounty = bounty? =~ bounty_re && $1 == arg
    if Spell[9056].active? && !has_bounty
      msg = "Group bounty in #{Spell[9056].timeleft.round(2)} minutes (ie #{(Spell[9056].timeleft * 60).round(0)} seconds)"
      fput "whisper ooc #{leader} #{msg}"
    end
    wait_while { Spell[9056].active? } unless has_bounty
    fput "whisper ooc #{leader} DONE"
    return
  elsif cmd == "wait_while_active" && arg.length > 0
    if Spell[arg].active?
      msg = "Waiting #{Spell[arg].timeleft} minutes (ie #{Spell[arg].timeleft * 60} seconds)"
      fput "whisper ooc #{leader} #{msg}"
    end
    wait_while { Spell[arg].active? }
    fput "whisper ooc #{leader} DONE"
    return
  end
  echo "SWITCH FALL THROUGH"
end

def wait_while_indisposed()
  sleep 0.25 while stunned? || waitrt?
end

def dothisloop(cmd, timeout, rsp_re)
  wait_while_indisposed()
  result = nil
  while result.nil?
    result = dothistimeout cmd, timeout, rsp_re
    break if result
    sleep 1
  end
end

def fix_vocal_cords()
  Script.pause("azbandit") if Script.running? "azbandit"
  wait_while_indisposed()
  fput "store left" if !(checkleft && checkright).nil?
  fput "stow left" if !(checkleft && checkright).nil?
  dothisloop "get my aloeas stem", 3, /You carefully remove some|You remove/
  dothisloop "eat my aloeas stem", 3, /You take a bite of/
  dothisloop "stow my stem", 3, /I could not find what|You put some/ if checkright == "stem" or checkleft == "stem"
  wait_while_indisposed()
  fput "gird"
  sleep 10
  Script.unpause("azbandit") if Script.running? "azbandit"
end

loop {
  while line = get?
    # (OOC) Azanoth's player whispers, "Do:exchange-unless:Muddy Village."
    if line =~ /slices deep into your vocal cords!$/ && Char.name == 'Gossan'
      fix_vocal_cords() # I'm not sure if we need this for other chars now that we have an empath
    elsif line =~ /^\(OOC\) (#{$AZ_CHARS_REGEX})'s player whispers, "Do:(.*?)\.?"/
      tokens = $2.split ":"
      run_cmd $1, tokens[0].downcase, tokens[1]
    end
  end
  sleep 0.1
}
