require 'drb/drb'
hide_me

DRb.start_service
$AZ_REMOTE = DRbObject.new_with_uri('druby://localhost:9999')

$AZ_CHARS = %w[Azanoth Aranthius Idios Gossan Helsfeld]
$AZ_CHARS_REGEX = /#{$AZ_CHARS.join('|')}/
$AZ_CHARS_SET = $AZ_CHARS.collect { |char| [char, true] }.to_h
$AZ_BANDIT_TARGET_SET = {}
'rogue marauder thief mugger bandit brigand robber outlaw thug highwayman'
  .split(' ')
  .each { |noun| $AZ_BANDIT_TARGET_SET[noun] = true }
$AZ_BOUNTY_PATTERN_NUM = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?.*\s(?:near|between|under|\.).* (\d+) (?:more )?of them/
$AZ_BOUNTY_PATTERN_FINISHED = /^You succeeded in your task/

$AZ_SEND_ACTION_SYNC =
  lambda do |char, cmd, arg = ''|
    ACTIONS = $AZ_REMOTE['actions']
    id = ACTIONS.queue_action char, cmd, arg
    loop do
      sleep 0.25
      action = ACTIONS.get_action char, id
      echo action
      throw 'Failed to get expected action' if !action
      if action['done']
        ACTIONS.clear_action char, id
        throw "ACTION HAS ERROR: #{action['error']}" if action['error']
        return
      end
    end
  end

$AZ_BANDIT_ATTACK =
  Proc.new do |attack_routine|
    # state
    poaching = false
    carried_line = nil

    # main loop
    i = -1
    while true
      i = i + 1
      fput 'stand' if !standing?

      # identify targets
      targets =
        GameObj.npcs.select do |npc|
          $AZ_BANDIT_TARGET_SET[npc.noun] && npc.status != 'dead' &&
            !npc.name.start_with?('animated ')
        end

      # check to see if we've moved, and whether we've progressed on bandits
      # we carry over the last line of the buffer to account for the situation
      # where we slurp a line that is important to our next loop iteration
      buffer = carried_line ? [carried_line] : []
      while line = get?
        buffer.push(line)
        carried_line = line
      end
      if carried_line &&
           (
             carried_line.start_with?('Obvious paths:') ||
               carried_line.start_with?('Obvious exits:')
           )
        # we don't want to consider this line in the next loop
        carried_line = nil
      end

      for i in 1..buffer.length
        line = buffer[buffer.length - i]

        # NEXT STEPS:
        # examine poaching_solution.lic and figure out exactly what else we need to
        # read from the buffer to build a complete picture of the scene, probably
        # with status_tags.
        # Hopefully reuse this logic in a function in azbandit

        if line.start_with?('Obvious paths:') ||
             line.start_with?('Obvious exits:')
          # previous line should be "Also here:" (unless we're leading)
          line = buffer[buffer.length - i - 1]
          if line && line.start_with?('Also here: ') &&
               line =~ /^Also here: (.*)/
            # Check to see if we'd be poaching
            pcs =
              $1
                .split(', ')
                .collect do |x|
                  x.sub(/ who is .*/, '').split(' ')[-1] # remove status suffix and prename title
                end
            poaching = pcs.any? { |x| !$AZ_CHARS_SET[x] }
          elsif line && !group?
            # I must be leading and not poaching
            poaching = false
          else
            # Er... there should be SOME line, like a room description
            echo 'WTF'
            echo "#{buffer.length} - #{i} - 1"
            echo buffer
            echo '-----------'

            # Following:
            # Lord Aranthius's group just went northeast.
            # [Muddy Village, Pathway - 29049]
            # The charred blah blah.
            # Also here: Gossan, Helsfeld, Idios, Lord Aranthius
            # Obvious paths: north, northeast, southwest
            # J>
            # Leading:
            # [azbandit]>northwest
            # [Black Weald, Sky Pond - 29228]
            # Far enough Blah blah
            # Obvious paths: southeast
            # Idios, Azanoth, Helsfeld and Gossan followed.
            # J>
            poaching = true
          end
          break
        end
      end

      if poaching || targets.nil? || targets.length == 0
        if checkcastrt == 0
          fput 'stance def' if checkstance != 'defensive'
        elsif checkstance != 'guarded'
          fput 'stance def'
        end
      elsif running? 'sloot'
        wait_while { running? 'sloot' }
      else
        attack_routine.call(targets)
      end

      rt = checkrt
      if rt > 2
        sleep(rt - 1)
      else
        sleep 0.25
      end
    end
  end

def wait_while_indisposed()
  sleep 0.25 while stunned? || waitrt?
end

def dothisloop(cmd, timeout, rsp_re)
  wait_while_indisposed
  result = nil
  while result.nil?
    result = dothistimeout cmd, timeout, rsp_re
    break if result
    sleep 1
  end
end

def fix_vocal_cords()
  Script.pause('azbandit') if Script.running? 'azbandit'
  wait_while_indisposed
  fput 'store left' if !(checkleft && checkright).nil?
  fput 'stow left' if !(checkleft && checkright).nil?
  dothisloop 'get my aloeas stem', 3, /You carefully remove some|You remove/
  dothisloop 'eat my aloeas stem', 3, /You take a bite of/
  if checkright == 'stem' or checkleft == 'stem'
    dothisloop 'stow my stem', 3, /I could not find what|You put some/
  end
  wait_while_indisposed
  fput 'gird'
  sleep 10
  Script.unpause('azbandit') if Script.running? 'azbandit'
end

$AZ_RUN_CMD =
  lambda do |cmd, arg|
    echo "run_cmd(#{cmd}, #{arg})"
    bounty_re = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?(.*)\s(?:near|between|under|\.)/
    if cmd == 'exchange-unless' && arg.length > 0
      if bounty? =~ bounty_re
        if $1 == arg
          echo 'ALREADY HAVE REQUESTED LOCATION'
          return true
        end
      end
      wait_while { Spell[9056].active? }
      fput 'ask luc to remove'
      fput 'ask luc to remove'
      return true
    elsif cmd == 'ungroup'
      fput 'disband'
      fput 'leave'
      fput 'group open'
      return true
    elsif cmd == 'start-script' && arg.length > 0
      Script.start(arg)
      return true
    elsif cmd == 'stop-script' && arg.length > 0
      Script.kill(arg) if running? arg
      return true
    elsif cmd == 'verify-done'
      return bounty? =~ /^You succeeded in your task/
    elsif cmd == 'wait_groupbounty_cooldown_unless' && arg.length > 0
      has_bounty = bounty? =~ bounty_re && $1 == arg
      if Spell[9056].active? && !has_bounty
        msg =
          "Group bounty in #{Spell[9056].timeleft.round(2)} minutes (ie #{(Spell[9056].timeleft * 60).round(0)} seconds)"
        fput "whisper ooc Aranthius #{msg}"
      end
      wait_while { Spell[9056].active? } unless has_bounty
      return true
    elsif cmd == 'wait_while_active' && arg.length > 0
      if Spell[arg].active?
        msg =
          "Waiting #{Spell[arg].timeleft} minutes (ie #{Spell[arg].timeleft * 60} seconds)"
        fput "whisper ooc Aranthius #{msg}"
      end
      wait_while { Spell[arg].active? }
      return true
    end
    echo 'SWITCH FALL THROUGH'
    return false
  end

$AZ_DO_WORK_SYNC =
  Proc.new do
    ACTIONS = $AZ_REMOTE['actions']
    actions = (ACTIONS.get_actions(Char.name) || []).reject { |x| x['done'] }
    actions.each do |action|
      success = $AZ_RUN_CMD.call(action['cmd'], action['args'])
      ACTIONS.mark_action_done(
        Char.name,
        action['id'],
        success ? nil : 'FAILED RUN_CMD'
      )
    end
  end

# TODO this just becomes a healer script
loop do
  while line = get?
    # (OOC) Azanoth's player whispers, "Do:exchange-unless:Muddy Village."
    if line =~ /slices deep into your vocal cords!$/ && Char.name == 'Gossan'
      fix_vocal_cords # I'm not sure if we need this for other chars now that we have an empath
    elsif line =~
          /^\(OOC\) (#{$AZ_CHARS_REGEX})'s player whispers, "Do:(.*?)\.?"/
      tokens = $2.split ':'

      # run_cmd $1, tokens[0].downcase, tokens[1]
      echo 'skipping run_cmd'
    end
  end
  $AZ_DO_WORK_SYNC.call
  sleep 0.25
end
