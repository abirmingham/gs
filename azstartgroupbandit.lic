args = script.vars[1..-1]
GROUP =
  if args.length > 0
    [Char.name, *args.collect { |name| name.capitalize }].uniq
  else
    $AZ_CHARS
  end

echo "GROUP: #{GROUP}"

throw 'No bounty' unless bounty?

if bounty? !~ /^You have been tasked/
  echo 'Waiting for bounty'
  wait_while do
    bounty? !~ /^You have been tasked/ || running?('fbandit') ||
      running?('go2') || running?('getbounty')
  end
  sleep 5
end

# clean up previous state
Script.running.each { |x| x.kill unless x == Script.current }
$AZ_REMOTE['actions'].clear_all_actions

# Identify bounty location
bounty_re = /^You have been tasked to (?:help \w+ )?suppress bandit activity (?:in|on|near|between|under) (?:the )?(.*)\s(?:near|between|under|\.)/
bounty_location = nil
bounty_location = $1 if bounty? =~ bounty_re
throw 'Failed to find bounty location' unless bounty_location

# Wait for share-ready
GROUP.each do |char|
  if Char.name != char
    $AZ_SEND_ACTION_SYNC.call char,
                              'wait_groupbounty_cooldown_unless',
                              bounty_location
  end
end

# Form group
GROUP.each do |char|
  $AZ_SEND_ACTION_SYNC.call char, 'ungroup' if Char.name != char
end

multifput 'disband', 'leave'
GROUP.each { |char| fput "hold #{char}" if Char.name != char }

# Set new group (clears previous counts)
$AZ_REMOTE['bandits'].set_new_group GROUP

# Share bounty
Script.run('go2', 'advguild')
if bounty? =~ $AZ_BOUNTY_PATTERN_NUM && $1.to_i
  $AZ_REMOTE['bandits'].set_count(Char.name, $1.to_i)
else
  raise 'Failed to find bounty'
end

GROUP.each do |char|
  if Char.name != char
    $AZ_REMOTE['actions'].queue_action char, 'exchange-unless', bounty_location
  end
end

Script.start 'prep'

i = 0
loop do
  sleep 1
  if i % 3 == 0
    # add chars
    GROUP.each { |char| put "ask luc to add #{char}" if Char.name != char }
  end
  i = i + 1

  # wait until everyone else has registered bounty count
  break if $AZ_REMOTE['bandits'].has_group_registered?
end

# Go!
waitrt?
sleep 3 # wait for warcry
Script.start 'azbandit'
